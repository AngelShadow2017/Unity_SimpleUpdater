using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

// ReSharper disable once CheckNamespace
namespace ZeroAs.ZeroAs_Core.ManualUpdaters
{

    // 标记类需要手动 Update 注册
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class ManualUpdaterAttribute : Attribute
    {
        public ManualUpdaterAttribute(ManualUpdateManager.UpdateOrder order = ManualUpdateManager.UpdateOrder.Normal)
        {
            Order = order;
        }
        public ManualUpdateManager.UpdateOrder Order { get; }
    }

    // 两个空接口，表明类支持 ManualUpdate 或 ManualFixedUpdate
    public interface IManualUpdater
    {
        void __F_ManualUpdate_AutoGenerated__();
    }

    public interface IFixedManualUpdater
    {
        void __F_ManualFixedUpdate_AutoGenerated__();
    }

    public interface IManualStarter
    {
        void __F_ManualStart_AutoGenerated__();
    }

    public class ManualUpdateManager
    {
        public enum UpdateType
        {
            Update,
            FixedUpdate
        }
        
        public enum UpdateOrder:int
        {
            Rigidbody2D,
            FakePosition,
            Normal,
            Tasker,
        }

        private static readonly Dictionary<UpdateOrder, int> shunts = new();
        private static readonly List<(Type,UpdateOrder[])> shuntConfigs = new()
        {
            (typeof(BeforeUpdateMonobehaviourManager),new []{UpdateOrder.Rigidbody2D,UpdateOrder.FakePosition}),
            (typeof(MonobehaviourManagers),new UpdateOrder[] { UpdateOrder.Normal,UpdateOrder.Tasker})
        };
        private static readonly List<MonobehaviourManagers> managers = new List<MonobehaviourManagers>();
        private static StarterManager starterManager;
        private static LateStarterInjector starterInjector;
        private static bool inited = false;
        internal static FrameLockManager frameLockManager = new FrameLockManager();
        public static PauseLock pauseLock = new PauseLock(); 
        private static void Init()
        {
            if (inited)
            {
                return;
            }

            inited = true;
            var shuntCount = shuntConfigs.Count;
            var minOrder = ((UpdateOrder[])Enum.GetValues(typeof(UpdateOrder)))/*.ToList()*/.Min();
            bool hadFlag = false;
            for (var index = 0; index < shuntCount; index++)
            {
                var config = shuntConfigs[index];
                if (!typeof(MonobehaviourManagers).IsAssignableFrom(config.Item1)) continue;
                var theManager = new GameObject().AddComponent(config.Item1) as MonobehaviourManagers;
                managers.Add(theManager);
                theManager.handles.AddRange(config.Item2);// 添加所有的 UpdateOrder
                theManager.allManagers = managers;
                theManager.Init();
                foreach (var order in config.Item2)
                {
                    shunts.TryAdd(order, index);
                    if (!hadFlag&&order==minOrder)
                    {
                        theManager.isFirstUpdateGroup = true;
                        hadFlag = true;
                    }
                }
            }

            {
                GameObject go = new GameObject("StarterManager");
                starterManager = go.AddComponent<StarterManager>();
                starterInjector = go.AddComponent<LateStarterInjector>();
                starterInjector.starterManager = starterManager;
            }
            frameLockManager.AddLock(pauseLock);
        }
        
        static ManualUpdateManager()
        {
            Init();
        }
#if UNITY_EDITOR
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool checker(MonoBehaviour obj)
        {
            if (obj == null)
            {
                Debug.LogError("ManualUpdateManager: MonoBehaviour is null, please check your script/generator.");
                return false;
            }

            return true;
        }
#endif

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RegisterUpdate<T>(T script,UpdateOrder order=UpdateOrder.Normal) where T:MonoBehaviour,IManualUpdater
        {
#if UNITY_EDITOR
            if (!checker(script)) { return;}
#endif
            managers[shunts[order]].RegisterUpdate(script,order);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RegisterFixed<T>(T script,UpdateOrder order=UpdateOrder.Normal) where T:MonoBehaviour,IFixedManualUpdater
        {
#if UNITY_EDITOR
            if (!checker(script)) { return;}
#endif
            managers[shunts[order]].RegisterFixed(script,order);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void UnregisterUpdate<T>(T script,UpdateOrder order=UpdateOrder.Normal) where T:MonoBehaviour,IManualUpdater
        {
            managers[shunts[order]].UnregisterUpdate(script,order);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void UnregisterFixed<T>(T script,UpdateOrder order=UpdateOrder.Normal) where T:MonoBehaviour,IFixedManualUpdater
        {
            managers[shunts[order]].UnregisterFixed(script,order);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RegisterStart<T>(T script,UpdateOrder order=UpdateOrder.Normal) where T:MonoBehaviour,IManualStarter
        {
#if UNITY_EDITOR
            if (!checker(script)) { return;}
#endif
            starterManager.RegisterStarter(script,order);
        }
        /*[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void UnregisterStart<T>(T script) where T:MonoBehaviour,IManualStarter
        {
            starterManager.UnregisterStarter(script);
        }*/
    }
}